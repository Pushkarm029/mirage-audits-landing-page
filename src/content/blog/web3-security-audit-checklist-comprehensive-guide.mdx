---
id: 6
title: "Web3 Security Audit Checklist: A Comprehensive Guide"
slug: "web3-security-audit-checklist-comprehensive-guide"
excerpt: "Master the complete Web3 security audit process with our detailed checklist covering smart contracts, DeFi protocols, and blockchain security best practices."
author: "Michael Zhang"
date: "2024-06-25"
category: "Security Guide"
tags: ["Audit", "Checklist", "Security", "Web3"]
readingTime: "25 min read"
featured: true
blockchain: "Multi-Chain"
---

Security auditing is a critical process in Web3 development. This comprehensive checklist covers all aspects of auditing smart contracts and DeFi protocols across different blockchain ecosystems.

## Pre-Audit Preparation

### 1. Documentation Review
- [ ] Read project whitepaper and documentation
- [ ] Understand the protocol's economic model
- [ ] Review tokenomics and incentive structures
- [ ] Analyze user flows and interaction patterns
- [ ] Identify key stakeholders and roles

### 2. Scope Definition
- [ ] Define audit boundaries and inclusions
- [ ] Identify all smart contracts in scope
- [ ] Review contract dependencies and libraries
- [ ] Understand upgrade mechanisms
- [ ] Document testing environment setup

### 3. Tool Setup
- [ ] Configure static analysis tools (Slither, Mythril)
- [ ] Set up dynamic analysis environment
- [ ] Prepare fuzzing tools (Echidna, Foundry)
- [ ] Install formal verification tools (if applicable)
- [ ] Set up blockchain development environment

## Smart Contract Security Checklist

### Access Control & Authorization

```solidity
// ✅ GOOD: Proper access control
contract SecureContract {
    address public owner;
    mapping(address => bool) public admins;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }
    
    modifier onlyAdmin() {
        require(admins[msg.sender], "Only admin");
        _;
    }
    
    function addAdmin(address admin) external onlyOwner {
        admins[admin] = true;
    }
}
```

**Checklist Items:**
- [ ] Owner/admin functions properly protected
- [ ] Multi-signature requirements for critical functions
- [ ] Ownership transfer mechanisms secure
- [ ] No hardcoded addresses or keys
- [ ] Proper modifier usage throughout contract

### Input Validation & Sanitization

```solidity
// ✅ GOOD: Input validation
function transfer(address to, uint256 amount) external {
    require(to != address(0), "Invalid recipient");
    require(to != address(this), "Cannot transfer to self");
    require(amount > 0, "Amount must be positive");
    require(amount <= balances[msg.sender], "Insufficient balance");
    
    // Perform transfer
    balances[msg.sender] -= amount;
    balances[to] += amount;
}
```

**Checklist Items:**
- [ ] All external inputs validated
- [ ] Address parameters checked for zero address
- [ ] Numeric inputs have reasonable bounds
- [ ] Array lengths validated before iteration
- [ ] External contract addresses verified
- [ ] String inputs properly sanitized

### Reentrancy Protection

```solidity
// ✅ GOOD: Reentrancy protection
contract ReentrancyGuard {
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;
    uint256 private _status = _NOT_ENTERED;
    
    modifier nonReentrant() {
        require(_status != _ENTERED, "Reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }
    
    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        
        balances[msg.sender] -= amount; // Update state first
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

**Checklist Items:**
- [ ] Reentrancy guards on external calls
- [ ] Checks-Effects-Interactions pattern followed
- [ ] State updates before external calls
- [ ] Pull-over-push payment patterns used
- [ ] Callback function security reviewed
- [ ] Cross-function reentrancy considered

### Integer Overflow & Underflow

```solidity
// ✅ GOOD: Safe math operations (Solidity 0.8+)
function safeTransfer(address to, uint256 amount) external {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    
    // Solidity 0.8+ has built-in overflow protection
    balances[msg.sender] -= amount;
    balances[to] += amount;
    
    // For older versions, use SafeMath library
    // balances[msg.sender] = balances[msg.sender].sub(amount);
    // balances[to] = balances[to].add(amount);
}
```

**Checklist Items:**
- [ ] SafeMath library used (pre-0.8) or overflow checks enabled
- [ ] Multiplication before division to avoid precision loss
- [ ] Checked arithmetic in critical calculations
- [ ] No unsafe type casting
- [ ] Proper handling of maximum values
- [ ] Division by zero protection

### Gas Optimization & DoS Prevention

```solidity
// ✅ GOOD: Gas-efficient and DoS-resistant
contract GasOptimized {
    mapping(address => uint256) public balances;
    
    // Use events for data that doesn't need on-chain storage
    event Transfer(address indexed from, address indexed to, uint256 value);
    
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        require(recipients.length == amounts.length, "Array length mismatch");
        require(recipients.length <= 100, "Too many recipients"); // DoS prevention
        
        for (uint256 i = 0; i < recipients.length; i++) {
            _transfer(msg.sender, recipients[i], amounts[i]);
        }
    }
}
```

**Checklist Items:**
- [ ] Gas limits considered for loops
- [ ] Array operations bounded
- [ ] Efficient data structure usage
- [ ] Unnecessary storage operations minimized
- [ ] Event emissions optimized
- [ ] External call gas stipends appropriate

## DeFi-Specific Security Checks

### Oracle Security

```solidity
// ✅ GOOD: Secure oracle usage
contract SecureOracle {
    AggregatorV3Interface internal priceFeed;
    uint256 public constant STALENESS_THRESHOLD = 3600; // 1 hour
    uint256 public constant DEVIATION_THRESHOLD = 500; // 5%
    
    function getSecurePrice() external view returns (uint256) {
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();
        
        require(price > 0, "Invalid price");
        require(updatedAt > 0, "Round not complete");
        require(
            block.timestamp - updatedAt <= STALENESS_THRESHOLD,
            "Price data stale"
        );
        
        return uint256(price);
    }
}
```

**Checklist Items:**
- [ ] Multiple oracle sources used
- [ ] Price staleness checks implemented
- [ ] Oracle manipulation resistance
- [ ] Circuit breakers for extreme price moves
- [ ] Fallback oracle mechanisms
- [ ] Time-weighted average prices (TWAP) considered

### Liquidity & Slippage Protection

```solidity
// ✅ GOOD: Slippage protection
function swapWithSlippageProtection(
    uint256 amountIn,
    uint256 minAmountOut,
    address tokenIn,
    address tokenOut
) external {
    uint256 expectedOut = calculateExpectedOutput(amountIn, tokenIn, tokenOut);
    require(minAmountOut <= expectedOut, "Insufficient output amount");
    
    uint256 actualOut = performSwap(amountIn, tokenIn, tokenOut);
    require(actualOut >= minAmountOut, "Slippage too high");
}
```

**Checklist Items:**
- [ ] Slippage protection mechanisms
- [ ] MEV protection strategies
- [ ] Front-running resistance
- [ ] Liquidity depth validation
- [ ] Impermanent loss considerations
- [ ] Flash loan attack resistance

### Flash Loan Security

```solidity
// ✅ GOOD: Flash loan protection
contract FlashLoanProtected {
    mapping(address => uint256) private balanceSnapshots;
    
    modifier noFlashLoan() {
        uint256 balanceBefore = token.balanceOf(address(this));
        _;
        uint256 balanceAfter = token.balanceOf(address(this));
        require(balanceAfter >= balanceBefore, "Flash loan detected");
    }
    
    function sensitiveFunction() external noFlashLoan {
        // Critical operations here
    }
}
```

**Checklist Items:**
- [ ] Flash loan detection mechanisms
- [ ] Multi-block transaction requirements
- [ ] Atomic transaction limitations
- [ ] State consistency across blocks
- [ ] Economic incentive analysis
- [ ] Governance token protection

## Platform-Specific Checks

### Ethereum/EVM Chains

**Checklist Items:**
- [ ] EIP compliance (ERC-20, ERC-721, etc.)
- [ ] Gas optimization for network fees
- [ ] MEV resistance strategies
- [ ] Layer 2 compatibility considerations
- [ ] Upgrade proxy patterns security
- [ ] Contract verification on Etherscan

### Solana

**Checklist Items:**
- [ ] Program Derived Address (PDA) security
- [ ] Account validation and ownership checks
- [ ] Signer validation for all instructions
- [ ] Rent exemption requirements
- [ ] Cross-Program Invocation (CPI) security
- [ ] Anchor framework best practices

### Cardano

**Checklist Items:**
- [ ] UTXO model security patterns
- [ ] Plutus script validation logic
- [ ] Datum and redeemer validation
- [ ] Value preservation checks
- [ ] Script size optimization
- [ ] Native token handling

### Sui

**Checklist Items:**
- [ ] Resource-oriented programming patterns
- [ ] Object ownership validation
- [ ] Capability-based access control
- [ ] Hot potato pattern usage
- [ ] Dynamic field security
- [ ] Move language best practices

## Testing & Verification

### Automated Testing

```solidity
// Example comprehensive test
contract SecurityTests {
    function testReentrancyProtection() public {
        vm.expectRevert("Reentrant call");
        attacker.performReentrancyAttack();
    }
    
    function testAccessControl() public {
        vm.prank(unauthorizedUser);
        vm.expectRevert("Only admin");
        contract.adminFunction();
    }
    
    function testOverflowProtection() public {
        vm.expectRevert(); // Should revert on overflow
        contract.unsafeAdd(type(uint256).max, 1);
    }
}
```

**Checklist Items:**
- [ ] Unit tests for all functions
- [ ] Integration tests for user flows
- [ ] Edge case and boundary testing
- [ ] Negative test cases
- [ ] Gas usage optimization tests
- [ ] Upgrade mechanism tests

### Formal Verification

**Checklist Items:**
- [ ] Critical invariants identified
- [ ] Property-based testing implemented
- [ ] Mathematical proofs for core logic
- [ ] Model checking for state machines
- [ ] Symbolic execution analysis
- [ ] Contract specification documentation

### Manual Review

**Checklist Items:**
- [ ] Business logic validation
- [ ] Economic model analysis
- [ ] Attack vector brainstorming
- [ ] Code complexity assessment
- [ ] Documentation quality review
- [ ] Deployment procedure validation

## Post-Audit Activities

### Remediation

**Checklist Items:**
- [ ] All findings categorized by severity
- [ ] Remediation strategies documented
- [ ] Code fixes implemented and tested
- [ ] Re-audit of critical changes
- [ ] Client communication and updates
- [ ] Final security assessment

### Documentation

**Checklist Items:**
- [ ] Comprehensive audit report
- [ ] Executive summary for stakeholders
- [ ] Technical details and recommendations
- [ ] Risk assessment and mitigation strategies
- [ ] Timeline for issue resolution
- [ ] Follow-up audit scheduling

### Monitoring

**Checklist Items:**
- [ ] Post-deployment monitoring setup
- [ ] Real-time alert systems
- [ ] Performance metrics tracking
- [ ] Security incident response plan
- [ ] Regular security reviews scheduled
- [ ] Community bug bounty programs

## Conclusion

This comprehensive checklist covers the essential aspects of Web3 security auditing. Remember that security is an ongoing process, not a one-time event. Regular audits, continuous monitoring, and staying updated with the latest security research are crucial for maintaining robust security posture.

Key takeaways:
- **Be thorough**: Every aspect of the system must be reviewed
- **Think like an attacker**: Consider all possible attack vectors
- **Test extensively**: Automated and manual testing are both essential
- **Document everything**: Clear documentation helps future audits
- **Stay updated**: The security landscape evolves rapidly

Security auditing requires both technical expertise and systematic methodology. Use this checklist as a foundation, but always adapt it to the specific requirements and risks of each project.